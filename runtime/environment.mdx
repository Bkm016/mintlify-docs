---
title: "环境与作用域"
description: "Environment 如何承载函数、变量与扩展"
---

`Environment` 是 Fluxon 执行期的“作用域 + 符号表”。解释器与编译执行引擎都会基于同一个 `Environment` 完成变量读写、
函数调用与扩展函数分派（`target::method(...)`）。

它管理的核心要素：

- **函数**：系统函数（含命名空间函数）。
- **扩展函数**：上下文调用 `target::method(...)`。
- **变量**：根变量（全局）与局部变量（函数调用作用域）。
- **上下文目标**：`target` 槽位（由 `::` 调用临时写入）。

<Note>`Environment` 通常通过 `FluxonRuntime#getInstance().newEnvironment()` 创建。注册新的函数/扩展/变量后，
重新创建环境以刷新运行时缓存。</Note>

## Root 与子环境

- **根环境（root）**：持有函数映射、扩展函数映射、根变量映射，以及运行时生成的缓存结构（用于加速调用分派）。
- **子环境（child）**：用于函数调用作用域，只存放局部变量数组与（可选的）局部变量名；通过 `root` 引用共享根数据。

## 函数解析

普通函数通过 `Environment#getFunction(name)` 在根函数表中查找；不存在会抛出 `FunctionNotFoundError`。

命名空间函数（如 `fs:time`）需要脚本先 `import 'fs:time'` 才会被解析到（见 [术语表](/appendix/glossary)）。

## 扩展函数解析（`target::method`）

扩展函数的匹配依赖 `target` 的宿主类型：

- 解析器在可优化的场景下会为调用点生成 `extensionPositionIndex`，运行时会使用 `root.dispatchTables[index]` 快速解析。
- 对于动态注册或无法提前编号的调用点，会回退到 `root.extensionFunctions.get(name)` 的映射，并按“精确类型 →
  isAssignableFrom”顺序匹配。

<Note>如果你在运行中动态注册了扩展函数，旧的 `Environment` 可能不会包含新的派发表缓存；建议在注册完成后重新 `newEnvironment()`。</Note>

## 变量与索引

变量访问在运行时以“索引”为主：

- `index = -1`：根变量（保存在 `rootVariables`）。
- `index >= 0`：局部变量（保存在 `localVariables[index]`），必要时沿 parent 链回溯。

当索引越界且不存在 parent 时会抛出 `VariableNotFoundError`，并附带 `localVariableNames` 以便定位问题。

## 上下文目标 `target`

上下文调用会把左侧表达式写入 `Environment#target`，再执行右侧函数/扩展；执行完成后解释器会恢复旧的 `target`。

## 调试与枚举

- `Environment#getRootFunctions()`：当前系统函数表。
- `Environment#getRootExtensionFunctions()`：当前扩展函数映射（类型 → Function）。
- `Environment#getRootVariables()`：当前根变量表（含宿主注入的对象）。
- `FunctionContext#toString()`：定位一次调用的 target 与参数。

## 相关链接

- [解释器执行流](/runtime/interpreter)
- [编译执行引擎](/runtime/execution-engine)
- [运行时注册 API](/developer/runtime-registry)
- [扩展函数 API](/developer/extension-api)
- [故障排查](/developer/troubleshooting)
