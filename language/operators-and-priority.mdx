---
title: "运算符与优先级"
description: "算术、比较、逻辑等运算符及其结合规则"
---

运算符决定表达式的组合与求值顺序。本章汇总核心运算符，并说明它们的优先级与结合性，便于阅读复杂表达式。

## 运算符总览

### 算术运算符

算术运算符用于数值计算，同时也支持部分字符串、集合等运行时扩展的实现：

| 运算符 | 描述     | 示例              |
|--------|----------|-------------------|
| `+`    | 加法     | `1 + 2`           |
| `-`    | 减法     | `&a - 3`           |
| `*`    | 乘法     | `&price * &count`   |
| `/`    | 除法     | `&total / &n`       |
| `%`    | 取模     | `&i % 2`           |

### 比较运算符

比较运算符返回布尔结果，可用于条件与分支：

| 运算符 | 描述         | 示例              |
|--------|--------------|-------------------|
| `==`   | 相等         | `&a == &b`        |
| `!=`   | 不相等       | `&status != ok`   |
| `>`    | 大于         | `&score > 90`     |
| `<`    | 小于         | `&x < 0`          |
| `>=`   | 大于等于     | `&n >= 1`         |
| `<=`   | 小于等于     | `&n <= 100`       |

### 逻辑运算符

逻辑运算符使用“真值语义”而不是仅限布尔类型，内部会调用运行时的 `isTrue` 判定：

| 运算符 | 描述     | 示例                     |
|--------|----------|-------------------------|
| `&&`   | 逻辑与   | `&ok && &enabled`       |
| `\|\|`   | 逻辑或   | `&fallback \|\| &primary` |
| `!`    | 逻辑非   | `!&flag`                |

逻辑运算符具有短路行为：

- `a && b`：当 `a` 为假时，不再计算 `b`。
- `a || b`：当 `a` 为真时，不再计算 `b`。

### 赋值与复合赋值

赋值运算符用于更新变量的当前值，结合引用运算符 `&` 在表达式中读取结果：

| 运算符 | 描述         | 示例               | 等价形式              |
|--------|--------------|--------------------|-----------------------|
| `=`    | 简单赋值     | `x = 1`            | —                     |
| `+=`   | 加法赋值     | `sum += &n`        | `sum = &sum + &n`     |
| `-=`   | 减法赋值     | `x -= 1`           | `x = &x - 1`          |
| `*=`   | 乘法赋值     | `total *= 2`       | `total = &total * 2`  |
| `/=`   | 除法赋值     | `avg /= 10`        | `avg = &avg / 10`     |
| `%=`   | 取模赋值     | `i %= 2`           | `i = &i % 2`          |

### 特殊运算符

Fluxon 还提供若干与控制流和语义糖相关的运算符：

| 运算符   | 描述                 | 示例                         |
|----------|----------------------|------------------------------|
| `..`     | 区间（闭区间）       | `1..10`                      |
| `..<`    | 区间（左闭右开）     | `0..< &n`                    |
| `?:`     | Elvis 运算符         | `&name ?: "anonymous"`      |
| `&`      | 变量引用运算符       | `sum = &a + &b`              |
| `::`     | 上下文调用运算符     | `&list :: size()`            |
| `.`      | 成员访问（反射）     | `&user.name` / `&list.size()` |

这些运算符在其他章节中有详细说明，本章主要关心它们在大表达式中的优先级关系。

## 运算符优先级

Fluxon 的表达式解析采用自顶向下递归下降和优先级划分。

| 类别                     | 示例                             |
|--------------------------|----------------------------------|
| 括号与字面量             | `(expr)`、`[1, 2]`、`[k: v]`     |
| 成员访问与函数调用       | `obj.name`、`obj.method()`、`f(x)` |
| 上下文调用 `::`          | `&target :: func()`              |
| 一元运算符               | `!expr`、`-expr`、`&name`        |
| 乘除模                   | `*`、`/`、`%`                    |
| 加减                     | `+`、`-`                         |
| 范围运算符               | `..`、`..<`                      |
| 比较运算符               | `> >= < <= == !=`                |
| 逻辑与/或                | `&&`、`||`                       |
| Elvis 运算符             | `?:`                             |
| 赋值与复合赋值           | `=`、`+=`、`-=` 等               |

括号 `(...)` 总是可以强制改变默认优先级：

```fluxon
result1 = 1 + 2 * 3      # 等价于 1 + (2 * 3) = 7
result2 = (1 + 2) * 3    # 等于 9
```

### 一元运算符与引用

一元运算符写在操作数前面：

```fluxon
flag = !&ok
delta = -&n
sum = &a + &b
```

引用 (`&`) 的优先级高于大多数二元运算符，因此 `&a + &b` 会被解析为 `(&a) + (&b)`，而不是 `&(a + b)`。

如果需要对整个表达式结果取引用（在部分语法中），应显式添加括号。

### 逻辑短路与结合方向

逻辑运算符是 **左结合** 的：

```fluxon
a && b && c    # 解析为 (a && b) && c
a || b || c    # 解析为 (a || b) || c
```

短路行为配合左结合，使得从左到右依次检查条件成为自然写法：

```fluxon
ready = &configLoaded && &connectionOk && &authorized
```

### Elvis 运算符

Elvis 运算符 `?:` 用于在左侧为 `null` 时返回右侧默认值：

```fluxon
name = &input ?: "anonymous"
```

它的优先级低于算术、比较和逻辑运算，一般规则是：

- 先计算 `&input` 的值。
- 如果结果为 `null`，返回右侧表达式的值；否则返回左侧。

如需限定参与 `?:` 的子表达式范围，可以使用括号：

```fluxon
value = (&a + &b) ?: 0
```

### 赋值的结合方向

赋值语句通常按从左到右依次执行更新，更推荐拆成多行，而不是写成链式形式：

```fluxon
b = 1
a = &b
```

这样更利于阅读和调试，也避免对赋值结果是否可参与运算的误解。

## 与上下文调用、函数调用的组合

上下文调用运算符 `::` 与函数调用优先级较高，它们在解析时会先于算术与逻辑运算生效：

```fluxon
result = &list :: filter(fn) :: size() > 0 && &enabled
```

大致解析为：

1. 先对 `&list` 做上下文调用，得到 `filter(fn)` 的结果。
2. 再在该结果上做第二次 `:: size()` 调用。
3. 对 `size()` 的返回值与 `0` 做比较。
4. 最后与 `&enabled` 做 `&&` 运算。

如需改变这一顺序，可以照常使用括号包裹需要整体计算的部分。

## 推荐写法

- 对于复杂表达式，宁可 **多写括号** 来表达意图，而不是依赖读者记住所有优先级规则。
- 在涉及 `&&` / `||` 与函数调用、上下文调用混用时，建议按 “每行一个逻辑步骤” 的方式拆分。
- 对赋值表达式的值有依赖时，推荐显式拆出中间变量，有助于调试和日志记录。

## 相关链接

- [字面量与类型](/language/literals-and-types)
- [变量与引用](/language/variables-and-references)
- [成员访问](/language/member-access)
- [Java 互操作](/language/java-interop)
- [函数与异步](/language/functions-and-async)
